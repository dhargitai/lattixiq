# Story 2.6: Implement Smart Navigation Logic - Seamless Learning Journey Continuation

## Status

Draft

## Story

**As a** returning user who has started a learning journey
**I want** the app to intelligently know where I left off and take me to the correct screen
**So that** I can continue seamlessly without confusion about what to do next

## Acceptance Criteria

1. Clicking on a roadmap step navigates to the appropriate screen based on current progress state
2. If step is unlocked but no plan created → Navigate to Learn screen
3. If plan exists but no reflection completed → Navigate to Reflect screen
4. If reflection completed → Show completion state with option to view next step
5. Users can navigate back to Learn screen from Reflect screen to review content
6. URL structure supports direct linking to any step state (e.g., `/learn/[stepId]`, `/reflect/[stepId]`)
7. Loading states prevent navigation errors and show proper skeletons
8. Route guards prevent users from skipping steps or accessing invalid states
9. Handles edge cases: expired plans, incomplete data, direct URL access
10. Navigation breadcrumbs update correctly based on current screen and progress
11. Back navigation preserves proper flow (Reflect → Learn → Roadmap)
12. Smart redirects handle incomplete journeys (e.g., accessing Reflect without a plan)
13. State persistence works across browser sessions and page refreshes
14. Mobile navigation patterns work smoothly with proper touch interactions

## Tasks / Subtasks

- [ ] Task 1: Write integration tests using TDD approach (AC: 1-14)
  - [ ] Create test file at `/lib/navigation/__tests__/smart-navigation.test.tsx`
  - [ ] Write test for navigation logic with different step states:
    - Unlocked step with no plan → Learn screen
    - Step with plan but no reflection → Reflect screen
    - Completed step → Completion state
  - [ ] Write test for URL direct access handling
  - [ ] Write test for route guards preventing invalid navigation
  - [ ] Write test for back navigation flow preservation
  - [ ] Write test for loading states during navigation
  - [ ] Write test for edge cases (expired data, malformed URLs)
  - [ ] Write test for breadcrumb navigation updates
  - [ ] Write test for state persistence across sessions
  - [ ] Write test for mobile navigation patterns

- [ ] Task 2: Create navigation utilities and state machine (AC: 1, 8, 12)
  - [ ] Create `/lib/navigation/smart-navigation.ts` with navigation logic:

    ```typescript
    export type NavigationState =
      | "learn" // No plan exists yet
      | "reflect" // Plan exists, no reflection
      | "completed" // Reflection completed
      | "locked"; // Step not available

    export function determineNavigationState(step: RoadmapStep): NavigationState {
      if (step.status === "locked") return "locked";
      if (step.status === "completed") return "completed";

      // Check if plan exists
      if (!step.plan_created_at) return "learn";

      // Check if reflection exists (via application_logs)
      // This will require a database query
      return "reflect";
    }

    export function getNavigationPath(stepId: string, state: NavigationState): string {
      switch (state) {
        case "learn":
          return `/learn/${stepId}`;
        case "reflect":
          return `/reflect/${stepId}`;
        case "completed":
          return `/roadmap?completed=${stepId}`;
        case "locked":
          return "/roadmap";
      }
    }
    ```

  - [ ] Add route validation utilities
  - [ ] Create navigation state persistence layer
  - [ ] Implement smart redirect logic for invalid states

- [ ] Task 3: Update RoadmapStep component with smart navigation (AC: 1, 2, 3, 4, 10)
  - [ ] Modify `/components/features/roadmap/RoadmapStep.tsx` to use smart navigation:
    ```typescript
    const handleClick = async () => {
      if (!isAvailable) return;

      // Determine current state by checking plan and reflection status
      const navigationState = await determineStepNavigationState(step.id);
      const targetPath = getNavigationPath(step.id, navigationState);

      router.push(targetPath);
    };
    ```
  - [ ] Add visual indicators for different states:
    - Learn state: "Start Learning" or "Continue Learning"
    - Reflect state: "Reflect on Experience"
    - Completed state: "View Results" with checkmark
  - [ ] Update step status display logic
  - [ ] Add progress indicators showing completion percentage

- [ ] Task 4: Create route guards and middleware (AC: 8, 9, 12)
  - [ ] Create `/lib/navigation/route-guards.ts` with validation:

    ```typescript
    export async function validateLearnAccess(
      stepId: string,
      userId: string
    ): Promise<{ allowed: boolean; redirect?: string }> {
      // Check if step is unlocked for user
      // Return redirect if invalid access
    }

    export async function validateReflectAccess(
      stepId: string,
      userId: string
    ): Promise<{ allowed: boolean; redirect?: string }> {
      // Check if plan exists for this step
      // Redirect to Learn if no plan
    }
    ```

  - [ ] Implement server-side route validation in each page.tsx
  - [ ] Add client-side navigation guards in components
  - [ ] Handle unauthorized access attempts
  - [ ] Create fallback redirects for edge cases

- [ ] Task 5: Update Learn screen with navigation enhancements (AC: 5, 11)
  - [ ] Modify `/app/(app)/learn/[stepId]/page.tsx` to support navigation from Reflect
  - [ ] Update "Continue to Plan" button logic:
    ```typescript
    const handleContinue = async () => {
      // Check if plan already exists
      if (step.plan_created_at) {
        // Navigate to Reflect instead of Plan
        router.push(`/reflect/${stepId}`);
      } else {
        // Navigate to Plan creation
        router.push(`/plan/${stepId}`);
      }
    };
    ```
  - [ ] Add "Back to Reflect" navigation option when accessed from Reflect
  - [ ] Update breadcrumb navigation context
  - [ ] Preserve navigation history for proper back button behavior

- [ ] Task 6: Create Reflect screen route structure (AC: 3, 5, 6, 7)
  - [ ] Create `/app/(app)/reflect/[stepId]/` directory structure
  - [ ] Create main page with reflection form and navigation:
    ```typescript
    // /app/(app)/reflect/[stepId]/page.tsx
    export default async function ReflectPage({ params }: { params: { stepId: string } }) {
      // Validate user has plan for this step
      // Redirect to Learn if no plan exists
      // Show reflection form if valid
    }
    ```
  - [ ] Add loading.tsx with skeleton matching reflection form
  - [ ] Create error.tsx for handling reflection access errors
  - [ ] Implement proper metadata and SEO for reflection pages

- [ ] Task 7: Implement completion state and next step unlocking (AC: 4, 10)
  - [ ] Create completion flow in Reflect screen
  - [ ] Add "View Next Step" navigation after reflection completion
  - [ ] Implement automatic step unlocking logic
  - [ ] Create celebration micro-interactions for completion
  - [ ] Update roadmap state immediately after reflection
  - [ ] Add analytics tracking for completion events

- [ ] Task 8: Update breadcrumb navigation system (AC: 10, 11)
  - [ ] Create `/components/ui/SmartBreadcrumb.tsx` component:
    ```typescript
    interface BreadcrumbState {
      roadmapTitle: string;
      stepTitle: string;
      currentScreen: "learn" | "plan" | "reflect" | "roadmap";
      canNavigateBack: boolean;
    }
    ```
  - [ ] Update breadcrumbs based on current navigation state
  - [ ] Add contextual navigation options (e.g., "Back to Learn" from Reflect)
  - [ ] Implement breadcrumb click handlers with proper validation
  - [ ] Add keyboard navigation support for breadcrumbs

- [ ] Task 9: Enhance state management for navigation (AC: 13)
  - [ ] Update `/lib/stores/roadmap-store.ts` with navigation state:
    ```typescript
    interface NavigationState {
      currentScreen: "roadmap" | "learn" | "plan" | "reflect";
      navigationHistory: string[];
      canGoBack: boolean;
      lastVisitedStep: string | null;

      setCurrentScreen: (screen: NavigationState["currentScreen"]) => void;
      pushNavigation: (path: string) => void;
      goBack: () => string | null;
    }
    ```
  - [ ] Add navigation state persistence across browser sessions
  - [ ] Implement navigation state cleanup on logout
  - [ ] Add optimistic updates for navigation state changes

- [ ] Task 10: Create loading states and error boundaries (AC: 7)
  - [ ] Create smart loading skeletons for each screen type
  - [ ] Add navigation-specific loading states:
    - "Checking your progress..."
    - "Loading your reflection..."
    - "Preparing next step..."
  - [ ] Implement error boundaries for navigation failures
  - [ ] Add retry mechanisms for failed navigation state checks
  - [ ] Create fallback navigation when state determination fails

- [ ] Task 11: Implement mobile navigation optimizations (AC: 14)
  - [ ] Add touch-friendly navigation elements
  - [ ] Implement swipe gestures for back navigation
  - [ ] Create mobile-specific navigation patterns
  - [ ] Add haptic feedback for navigation actions
  - [ ] Optimize button sizes and spacing for mobile
  - [ ] Test navigation flow on various mobile devices

- [ ] Task 12: Add navigation analytics and monitoring (AC: 1-14)
  - [ ] Track navigation pattern analytics:
    - Most common navigation paths
    - Drop-off points in learning flow
    - Back navigation usage patterns
  - [ ] Add error tracking for navigation failures
  - [ ] Monitor loading times for navigation state determination
  - [ ] Create dashboard for navigation flow insights
  - [ ] Add A/B testing framework for navigation improvements

- [ ] Task 13: Verify all tests pass and navigation flows work (AC: 1-14)
  - [ ] Run full test suite with all navigation tests
  - [ ] Test complete user journeys:
    - Fresh user: Roadmap → Learn → Plan → Reflect → Next Step
    - Returning user: Direct access to various URLs
    - Interrupted journey: Browser refresh, network issues
  - [ ] Test edge cases and error scenarios
  - [ ] Verify mobile navigation flows
  - [ ] Performance testing for navigation state determination
  - [ ] Cross-browser compatibility testing
  - [ ] User acceptance testing with navigation scenarios

## Dev Notes

### Previous Story Insights

From Story 2.1 (Learn Screen):

- Learn screen route structure established at `/app/(app)/learn/[stepId]/`
- Component patterns use forwardRef and proper TypeScript interfaces
- Loading states handled via Next.js patterns
- Authentication and ownership validation implemented

From Story 2.5 (Reflect Screen):

- Reflect screen will be at `/app/(app)/reflect/[stepId]/`
- Reflection completion triggers step status update to 'completed'
- Next step automatically unlocked after reflection
- Plan data required before accessing reflection

From Epic 2 requirements:

- Story 2.6 has 8 story points (medium-high complexity)
- Navigation is critical for user experience and retention
- Must handle all edge cases gracefully
- URL structure should support direct linking

### Architecture Requirements

**Navigation State Machine:**
Following software engineering best practices:

- Clear state definitions (learn, reflect, completed, locked)
- Deterministic state transitions
- Error handling for invalid state transitions
- State persistence across sessions

**Route Structure:**
Current and planned routes:

```text
/roadmap                    # Main roadmap view
/learn/[stepId]            # Learn screen (existing)
/plan/[stepId]             # Plan creation (existing)
/reflect/[stepId]          # Reflection screen (to be created)
```

**Database Integration:**
Navigation state determined by:

- `roadmap_steps.status` ('locked', 'unlocked', 'completed')
- `roadmap_steps.plan_created_at` (indicates plan exists)
- `application_logs.roadmap_step_id` (indicates reflection completed)

### Smart Navigation Logic

**State Determination Algorithm:**

```typescript
function determineNavigationState(step: RoadmapStep, hasReflection: boolean): NavigationState {
  // Step must be unlocked to access
  if (step.status === "locked") return "locked";

  // If reflection completed, show completion state
  if (hasReflection || step.status === "completed") return "completed";

  // If plan exists but no reflection, go to reflect
  if (step.plan_created_at) return "reflect";

  // No plan exists, start with learn
  return "learn";
}
```

**URL Pattern Design:**

- Direct URL access should work for any valid state
- Invalid access should redirect to appropriate starting point
- Query parameters can provide context (e.g., `?from=reflect`)

### Component Integration

**RoadmapStep Updates:**

- Visual indicators for different states (icons, text, colors)
- Smart click handlers based on current state
- Progress indicators showing completion percentage
- Accessibility improvements for state communication

**Navigation Components:**

- Smart breadcrumbs showing current context
- Back navigation preserving proper flow
- Loading states during state determination
- Error handling for navigation failures

### Data Models

**Navigation State Interface:**

```typescript
interface StepNavigationState {
  stepId: string;
  status: RoadmapStepStatus;
  hasPlan: boolean;
  hasReflection: boolean;
  navigationState: NavigationState;
  targetPath: string;
  allowedTransitions: NavigationState[];
}
```

**Route Guard Response:**

```typescript
interface RouteGuardResult {
  allowed: boolean;
  redirect?: string;
  reason?: string;
  fallbackPath?: string;
}
```

### Error Handling Strategy

**Navigation Failures:**

- Network errors during state determination
- Malformed URLs or invalid step IDs
- Authentication failures
- Database inconsistencies

**Fallback Behavior:**

- Redirect to roadmap view as safe fallback
- Show error message with retry option
- Preserve user's intended destination
- Log errors for debugging and improvement

### Performance Considerations

**State Determination Optimization:**

- Cache navigation states in Zustand store
- Batch database queries for multiple steps
- Use optimistic updates for better perceived performance
- Implement request deduplication for repeated checks

**Loading State Management:**

- Show immediate feedback for navigation actions
- Progressive loading for complex state determination
- Skeleton screens matching target content
- Timeout handling for slow state checks

### Security Considerations

**Access Control:**

- Validate user ownership of roadmap steps
- Prevent unauthorized access to reflection data
- Rate limiting on navigation state queries
- CSRF protection on state-changing navigation

**Data Privacy:**

- No sensitive data in URL parameters
- Secure handling of navigation state in localStorage
- Proper cleanup of cached navigation data on logout

### Testing Strategy

**Integration Test Priorities:**

- Complete navigation flows for each user journey
- Edge case handling (network failures, invalid states)
- Cross-screen navigation with proper state updates
- URL direct access and deep linking functionality

**User Journey Testing:**

- New user onboarding flow
- Returning user continuation flows
- Interrupted journey recovery
- Mobile navigation patterns

### File Locations

**To be created:**

- `/lib/navigation/smart-navigation.ts` - Core navigation logic
- `/lib/navigation/route-guards.ts` - Route validation utilities
- `/lib/navigation/__tests__/smart-navigation.test.tsx` - Navigation tests
- `/components/ui/SmartBreadcrumb.tsx` - Enhanced breadcrumb component
- `/app/(app)/reflect/[stepId]/page.tsx` - Reflect screen route
- `/app/(app)/reflect/[stepId]/loading.tsx` - Reflect loading state
- `/app/(app)/reflect/[stepId]/error.tsx` - Reflect error boundary

**To be modified:**

- `/lib/stores/roadmap-store.ts` - Add navigation state management
- `/components/features/roadmap/RoadmapStep.tsx` - Smart navigation integration
- `/app/(app)/learn/[stepId]/page.tsx` - Enhanced navigation support

### Success Metrics

Following Epic 2 success criteria:

- 70% of users complete their first reflection (improved navigation should help)
- Reduced bounce rate on learning screens
- Higher completion rate for interrupted journeys
- Faster time to task completion for returning users
- Lower support requests about "what to do next"

### Risk Mitigation

**Navigation State Complexity:**

- Thorough testing of all state combinations
- Clear documentation of navigation logic
- Monitoring for navigation failures
- Fallback paths for unexpected states

**Performance Impact:**

- Optimize database queries for state determination
- Cache navigation states appropriately
- Monitor navigation response times
- Load testing for navigation endpoints

**User Experience Risks:**

- Confusing navigation flows
- Unexpected redirects
- Loss of user progress
- Mobile navigation issues

## Change Log

| Date       | Version | Description            | Author             |
| ---------- | ------- | ---------------------- | ------------------ |
| 2025-08-04 | 1.0     | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent_

### Completion Notes List

_To be populated by Dev Agent_

### File List

_To be populated by Dev Agent_

## QA Results

_To be populated by QA Agent_
