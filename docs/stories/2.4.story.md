# Story 2.4: Implement Reminder Notification System

## Status

Approved

## Story

**As a** user who has created an implementation plan or spotting mission
**I want** to receive a daily reminder at my chosen time
**So that** I remember to practice and reflect on my learning, leading to consistent progress

## Business Context

This story is critical for user retention and engagement. Without reminders, users will forget to practice their plans, leading to abandoned roadmaps and poor retention. The reminder system uses a global user-level setting that sends daily reminders when any active plan exists, making it simple to manage and understand.

## Acceptance Criteria

### Core Functionality

1. **Global Reminder Settings**
   - [ ] User has one global reminder setting (ON/OFF and time)
   - [ ] Settings stored at user level, not per roadmap step
   - [ ] When ON and time is set (e.g., 15:00), reminders send daily at that time
   - [ ] Reminders only sent when user has an active plan (not completed/reflected)
   - [ ] Time zone is handled correctly based on user's local time

2. **Plan Page Integration**
   - [ ] Existing Plan screen reminder components show current global settings
   - [ ] If user has reminders OFF globally, plan page shows OFF
   - [ ] If user has reminders ON at 11:00, plan page shows ON at 11:00
   - [ ] Changing reminder settings on plan page updates global user settings
   - [ ] Settings persist when user saves the plan
   - [ ] No new components needed - Plan screen already has reminder section

3. **Notification Content**
   - [ ] Title: "Time to practice your plan"
   - [ ] Body: Shows the current active plan details (situation/trigger/action or spotting mission)
   - [ ] Action button: "Open LattixIQ" that deep-links to the Reflect screen
   - [ ] No notification sent if no active plan exists
   - [ ] Preview shows what the notification will look like

4. **Delivery & Reliability**
   - [ ] Notifications are sent reliably at the chosen time
   - [ ] Works on both mobile (PWA) and desktop browsers
   - [ ] Handles device offline scenarios gracefully
   - [ ] Respects user's Do Not Disturb settings
   - [ ] Graceful fallbacks if notification permissions are denied

5. **User Control & Settings**
   - [ ] Reminder toggle and time picker on plan creation/edit screen
   - [ ] Settings reflect and update global user preferences
   - [ ] Settings page shows same global reminder preferences (future epic)
   - [ ] Clear messaging that reminders are global, not per-plan

### Technical Requirements

6. **Cross-Platform Support**
   - [ ] Web Push API for desktop browsers
   - [ ] Service Worker for background processing
   - [ ] PWA manifest for mobile installation
   - [ ] iOS Safari compatibility (limited but functional)

7. **Database & State Management**
   - [ ] Reminder preferences stored in user_settings table only
   - [ ] No plan-specific reminder flags needed
   - [ ] System checks for active plans when sending reminders
   - [ ] Notification delivery logs for debugging
   - [ ] Simple, clean data model

## Technical Architecture

### Database Schema Updates

```sql
-- Add reminder preferences to user_settings
ALTER TABLE user_settings ADD COLUMN IF NOT EXISTS reminder_enabled BOOLEAN DEFAULT false;
ALTER TABLE user_settings ADD COLUMN IF NOT EXISTS reminder_time TIME DEFAULT '09:00'::time;
ALTER TABLE user_settings ADD COLUMN IF NOT EXISTS reminder_timezone TEXT DEFAULT 'UTC';
ALTER TABLE user_settings ADD COLUMN IF NOT EXISTS reminder_last_sent TIMESTAMP WITH TIME ZONE;

-- Create notification delivery log table
CREATE TABLE IF NOT EXISTS notification_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  roadmap_step_id UUID REFERENCES roadmap_steps(id) ON DELETE CASCADE,
  notification_type TEXT NOT NULL DEFAULT 'daily_reminder',
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  scheduled_for TIMESTAMP WITH TIME ZONE,
  delivered_at TIMESTAMP WITH TIME ZONE,
  delivery_status TEXT, -- 'sent', 'failed', 'blocked', 'no_active_plan'
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Service Worker Architecture

```typescript
// /public/sw.js
const REMINDER_CACHE = "lattixiq-reminders-v1";

self.addEventListener("push", (event) => {
  if (event.data) {
    const data = event.data.json();
    const options = {
      body: data.body,
      icon: "/icon-192x192.png",
      badge: "/badge-72x72.png",
      tag: `reminder-${data.stepId}`,
      data: {
        url: data.deepLink,
      },
      actions: [
        {
          action: "open-app",
          title: "Open LattixIQ",
        },
        {
          action: "dismiss",
          title: "Dismiss",
        },
      ],
    };

    event.waitUntil(self.registration.showNotification(data.title, options));
  }
});

self.addEventListener("notificationclick", (event) => {
  event.notification.close();

  if (event.action === "open-app" || !event.action) {
    event.waitUntil(clients.openWindow(event.notification.data.url));
  }
});
```

### API Endpoints

```typescript
// /app/api/notifications/preferences/route.ts
export async function GET() {
  // Get user's reminder preferences
}

export async function PUT(request: Request) {
  // Update user's reminder preferences
}

// /app/api/notifications/schedule/route.ts
export async function POST(request: Request) {
  // Schedule notification for specific plan
}

// /app/api/notifications/cron/route.ts (Edge Function)
export async function GET() {
  // Daily cron job to send notifications
  // 1. Get all users with reminders enabled for current time
  // 2. For each user, check if they have an active plan
  // 3. If active plan exists, send reminder with plan details
  // 4. Log delivery status (including 'no_active_plan' if applicable)
}
```

### Frontend Components

#### Reminder Settings Component

```typescript
// /components/features/settings/ReminderSettings.tsx
interface ReminderSettingsProps {
  initialEnabled: boolean;
  initialTime: string;
  onSave: (settings: ReminderSettings) => void;
}

export function ReminderSettings({ initialEnabled, initialTime, onSave }: ReminderSettingsProps) {
  const [enabled, setEnabled] = useState(initialEnabled);
  const [time, setTime] = useState(initialTime);
  const [permissionStatus, setPermissionStatus] = useState<NotificationPermission>('default');

  const requestNotificationPermission = async () => {
    if ('Notification' in window) {
      const permission = await Notification.requestPermission();
      setPermissionStatus(permission);
      return permission === 'granted';
    }
    return false;
  };

  const handleSave = async () => {
    if (enabled && permissionStatus !== 'granted') {
      const granted = await requestNotificationPermission();
      if (!granted) {
        toast.error('Please allow notifications to enable reminders');
        return;
      }
    }

    await onSave({ enabled, time });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Daily Reminders</CardTitle>
        <CardDescription>
          Get reminded to practice your plans at your chosen time
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex items-center space-x-2">
            <Switch
              checked={enabled}
              onCheckedChange={setEnabled}
              disabled={!('Notification' in window)}
            />
            <Label>Enable daily reminders</Label>
          </div>

          {enabled && (
            <div>
              <Label>Reminder time</Label>
              <Input
                type="time"
                value={time}
                onChange={(e) => setTime(e.target.value)}
              />
            </div>
          )}

          {permissionStatus === 'denied' && (
            <Alert>
              <AlertDescription>
                Please enable notifications in your browser settings to use reminders
              </AlertDescription>
            </Alert>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

#### Plan Screen Integration

```typescript
// The Plan screen already has reminder components in place
// These existing components need to be updated to:
// 1. Load and display the global reminder settings from user_settings
// 2. Update the global settings when changed
// 3. Add a small note that these are global settings

// Example of updating existing Plan screen component:
// /app/(main)/roadmap/[roadmapId]/steps/[stepId]/plan/page.tsx
export default function PlanPage() {
  // Fetch global reminder settings
  const { data: userSettings } = useUserSettings();

  // When saving plan, also update global reminder settings
  const handleSave = async (planData) => {
    // Save plan data
    await savePlan(planData);

    // Update global reminder settings if changed
    if (
      planData.reminderEnabled !== userSettings.reminder_enabled ||
      planData.reminderTime !== userSettings.reminder_time
    ) {
      await updateUserSettings({
        reminder_enabled: planData.reminderEnabled,
        reminder_time: planData.reminderTime,
      });
    }
  };

  // Existing Plan screen JSX with reminder section
  // No new components needed
}
```

## Implementation Tasks

### Phase 1: Database & Backend Setup (Day 1)

- [ ] **Task 1.1**: Run database migration to add reminder fields
- [ ] **Task 1.2**: Create notification_logs table and indexes
- [ ] **Task 1.3**: Update Prisma schema or Supabase types
- [ ] **Task 1.4**: Create API endpoints for reminder preferences
- [ ] **Task 1.5**: Create Edge Function for daily cron job (schedule notifications)

### Phase 2: Service Worker & PWA Setup (Day 2)

- [ ] **Task 2.1**: Create service worker file with notification handlers
- [ ] **Task 2.2**: Register service worker in Next.js app
- [ ] **Task 2.3**: Add PWA manifest with notification capabilities
- [ ] **Task 2.4**: Test service worker registration and basic notifications

### Phase 3: Frontend Components (Day 3-4)

- [ ] **Task 3.1**: Create ReminderSettings component for settings page
- [ ] **Task 3.2**: Update existing Plan screen reminder section to use global settings
- [ ] **Task 3.3**: Create notification preview component
- [ ] **Task 3.4**: Add notification permission handling
- [ ] **Task 3.5**: Implement time zone handling
- [ ] **Task 3.6**: Add logic to check for active plans before sending reminders

### Phase 4: Integration & Testing (Day 5-7)

- [ ] **Task 4.1**: Connect frontend components to API endpoints
- [ ] **Task 4.2**: Test end-to-end reminder flow
- [ ] **Task 4.3**: Test cross-platform compatibility (iOS, Android, desktop)
- [ ] **Task 4.4**: Add integration tests for reminder functionality
- [ ] **Task 4.5**: Performance testing for cron job execution

### Phase 5: Polish & Edge Cases (Day 8)

- [ ] **Task 5.1**: Handle notification permission denials gracefully
- [ ] **Task 5.2**: Add fallback UI if notifications unavailable
- [ ] **Task 5.3**: Implement reminder cleanup on plan completion
- [ ] **Task 5.4**: Add user-friendly error messages
- [ ] **Task 5.5**: Final QA testing across devices

## Testing Strategy

### Unit Tests

```typescript
// Test notification permission handling
describe("NotificationPermission", () => {
  it("should request permission when enabling reminders", async () => {
    // Test implementation
  });

  it("should handle denied permissions gracefully", () => {
    // Test implementation
  });
});
```

### Integration Tests

```typescript
// Test API endpoints
describe("Reminder API", () => {
  it("should save reminder preferences", async () => {
    // Test implementation
  });

  it("should schedule notifications correctly", async () => {
    // Test implementation
  });
});
```

### E2E Tests

```typescript
// Test complete reminder flow
describe("Reminder Flow", () => {
  it("should create plan, enable reminder, and receive notification", () => {
    // Test implementation using Playwright
  });
});
```

## Risk Mitigation

### Technical Risks

1. **Browser Compatibility**: Safari iOS has limited PWA support
   - _Mitigation_: Provide fallback UI and clear messaging
   - _Testing_: Test on actual iOS devices

2. **Notification Reliability**: Service workers can be killed by browsers
   - _Mitigation_: Use Supabase Edge Functions for server-side scheduling
   - _Monitoring_: Add delivery tracking and retry logic

3. **Time Zone Issues**: Users traveling across time zones
   - _Mitigation_: Store timezone with preferences, update on location change
   - _Testing_: Test with different timezone scenarios

### User Experience Risks

1. **Permission Fatigue**: Users may deny notification permissions
   - _Mitigation_: Explain value proposition clearly before requesting
   - _Fallback_: Allow email reminders as alternative

2. **Over-notification**: Daily reminders might be annoying
   - _Mitigation_: Single global reminder setting, not per-plan
   - _Settings_: Easy ON/OFF toggle accessible from plan page
   - _Smart_: Only sends when active plan exists

## Success Metrics

### Technical Metrics

- [ ] 95% of reminder requests successfully scheduled
- [ ] 80% of scheduled notifications successfully delivered
- [ ] <5 second response time for preference updates
- [ ] Zero data loss in notification logs

### User Metrics

- [ ] 60% of users enable reminders after creating first plan
- [ ] 70% of reminder-enabled users complete their plan within 7 days
- [ ] <5% of users disable reminders due to over-notification
- [ ] 90% user satisfaction with reminder timing accuracy

## Dev Notes

### Previous Story Context

From Story 2.3 (Reflect Screen):

- Plan data is stored in roadmap_steps table
- Users can navigate directly to reflect screen
- Database uses snake_case naming convention
- Navigation flow: Roadmap → Learn → Plan → Reflect

### Architecture Decisions

- **Global Settings**: Reminders are user-level, not plan-specific
- **Simplicity**: One setting to rule them all - reduces complexity
- **Plan Page Integration**: Uses existing reminder components, just updates behavior
- **Smart Delivery**: Only sends when active plan exists
- **Minimal Changes**: Leverages existing Plan screen reminder UI

### Dependencies

- Requires completed Story 2.3 (Reflect Screen)
- May need Supabase Edge Functions for cron scheduling
- Service Worker registration requires HTTPS (production)

### File Structure

```
/app/api/notifications/
├── preferences/route.ts
├── schedule/route.ts
└── cron/route.ts (Edge Function)

/components/features/settings/
└── ReminderSettings.tsx

# Note: Plan screen already has reminder components
# No new components needed for Plan screen

/public/
├── sw.js
├── manifest.json
└── icon-*.png

/lib/notifications/
├── notification-service.ts
├── permission-manager.ts
└── timezone-utils.ts
```

### Technical Stack Updates

- **Service Worker**: For background notification handling
- **Web Push API**: For cross-platform notifications
- **Vercel Edge Functions**: For cron job scheduling
- **Supabase**: For notification logs and preferences
- **PWA**: For mobile app-like experience

## Change Log

| Date       | Version | Description                                          | Author             |
| ---------- | ------- | ---------------------------------------------------- | ------------------ |
| 2025-08-04 | 1.0     | Initial story creation                               | Claude (AI Agent)  |
| 2025-08-04 | 2.0     | Revised to global reminder architecture per feedback | Bob (Scrum Master) |
| 2025-08-04 | 2.1     | Clarified that Plan screen already has reminder UI   | Bob (Scrum Master) |

## Dev Agent Record

### Pre-implementation Notes

- **Complexity**: HIGH - This is the most technically complex story in Epic 2
- **Dependencies**: Requires Edge Functions and Service Worker setup
- **Testing**: Needs real device testing for accurate notification behavior
- **Risk**: Cross-platform notification reliability is challenging
- **UI Note**: Plan screen already has reminder components - just update behavior

### Recommended Approach

1. Start with basic reminder preferences (no notifications)
2. Add notification permission handling
3. Implement service worker and push API
4. Add Edge Function for scheduling
5. Full integration and testing

### Testing Environment Setup

- Requires HTTPS for service workers (use ngrok for local testing)
- Test on iOS Safari, Android Chrome, and desktop browsers
- Set up test notifications that fire every minute for rapid iteration
- Use Supabase local development for database testing
